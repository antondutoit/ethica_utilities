---
title: "Ethica_utilities"
author: "A.T. du Toit"
date: "`r Sys.Date()`"
output: html_document
---

```{r To do}
# [IP] Clarify survey and activity numbers with Amin or Mohammad and alter naming conventions accordingly 
 
# [  ] Split this into a source file with funs and patterns and a workflow file (ie the remainder of this one)
# [  ] ? make generic col names shorter 
# [ip] move all patterns into one initial block and annotate what they are used for 
# [ip] change variable names to agree with Avicenna's new naming scheme (Study / Activity / Survey) 
# [  ] use vectors in str_remove() instead of repeated calls 

# DONE 

# [x ] add activity or survey numbers at the start of column names 
# [x ] use repeated() in line 82f. 
# [x ] Function to join data frames into one 

# [x ] Fix naming of MAQ questions 
# [x ] Function to extract data frames from list 

```


```{r Frontmatter and instructions and notes}
# This script processes CSV files as output from Avicenna/Ethica. 
# To use this script with your data files: 
#   - the files must be in CSV format. 
#   - change the file path in "Define names and constants" to point at the folder with your data files. 
# The script will output a dataframe for each CSV file; dataframes will be named xxx Survey.Number_df. The dataframe will have clean numerical output for single-answer questions, and also will have all variables renamed as Survey.Number_Question.Number_Question.Type. 
# If you want a CSV file outputted as well, you may un-comment the write.csv() call at the end of this file and add in the appropriate file path. 

```


```{r load libraries, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# Load libraries ----
library(rebus)
library(tidyverse)      # edit to include only the individual packages needed
library(magrittr)
library(conflicted)

```

```{r set preferences}
conflicts_prefer(rebus::alpha())   
```

## Define names and constants
```{r Create: Define names and constants}
# NB backslashes must be changed into forward slashes   # [ ] make or find a wee function to do this   
data_path <- "C:/Users/atdut/OneDrive - Western Sydney University/PhD/Rwork/ethica_utilities/data_files_json"

```

```{r Create: patterns for regex - will go into source file}
pattern1 <- "activity_response_" %R% repeated(DGT, lo = 4, hi = 5) # NB this extracts the *Study* no., not the activity no.



```


## Read in test data files   
```{r Create: read in test data files}

```

## Functions for reading in Avicenna data files   
```{r Create: functions for reading in Avicenna data files}

```


## Functions for file naming and variable renaming    
```{r Create: functions for file naming and variable renaming}
# Load and rename CSV files ----
file_names <- Sys.glob(paste0(data_path, "/*.csv"))

# Set up empty objects 
df_names <- data.frame()
activity_numbers <- vector()
df_list <- list()

# extract study number
study_number <- str_extract(file_names[1], pattern = pattern1)
study_number <- study_number %>% str_remove_all("activity_response_")

# Create data frame names from file_names and read in data from CSV files -----
i <- 0

for (file_name in file_names) {
  i <- i + 1
# Extract survey number; this expression will extract 3- to 6-digit survey numbers.
  
  str_extract(file_name, pattern = "activity_response_" %R% repeated(DGT,4,5) %R% "_" %R% repeated(DGT,5,6) )
  str_remove_all("activity_response_" %R% repeated(DGT,4,5) %R% "_")
  
activity_numbers[i] <- str_extract(file_name, pattern = "_" %R% repeated(DGT, 5, 6) %R% "_")
activity_numbers[i] <- activity_numbers[i] %>% str_remove_all("_")

# Generate df names from CSV file names
df_name <- paste0("S", study_number, "_", activity_numbers[i], "_df", collapse = NULL)

df_names <- c(df_names, df_name)
df_names <- as.vector(df_names, mode = "character")
df_list[[df_name]] <- read_csv(file_name, col_names = TRUE, na = c("", "NA"))
  }

```

```{r Fix:    Clean column names, detect and remove columns with answer labels}
for (df_name in df_names)  {
  df_list[[df_name]] %<>% janitor::clean_names()
  }

pattern2 <- "_" %R% repeated("[a-z]", lo = 3, hi = 3) %R% "_question_" %R% "[0-9]"
pattern2.1 <- DGT %R% optional(DGT) %R% "_maq_metadata_question_"

for (df_name in df_names)  {
  df_list[[df_name]] %<>% select(!matches(pattern2))
  df_list[[df_name]] %<>% select(!matches(pattern2.1))
 }

```

```{r Fix:    extract numeric answer codes and rewrite answer columns}
# pattern for extracting numeric answer codes 
pattern1.3 <- "\\{\"answer_id" %R% repeated(not_dgt(), lo = 2, hi = 28) %R% capture(DGT) %R% capture(optional(DGT)) %R% one_or_more(printable())

number_extract_single2 <- function(x) {
  as.numeric(str_replace(x, pattern = pattern1.3, replacement = REF1))
  }

# detect 'metadata' answer columns and rewrite content 
for (df_name in df_names)  {
  df_list[[df_name]] %<>% mutate(across(contains("_metadata_"), number_extract_single2))
 }

```


```{r Fix:    rename answer columns}
# pattern3.1 <- "_" %R% repeated("[a-z]", lo = 3, hi = 3) %R% "_metadata_question_" %R% capture(DGT) %R% #   repeated(capture(optional(DGT)),0,2) %R% "_of_survey_" %R% (DGT) %R%
#   repeated(optional(DGT),0,5)

pattern3.3 <- START %R% "x" %R% capture(repeated(DGT,0,2)) %R% "_" %R% repeated("[a-z]", lo = 3, hi = 3) %R% "_" %R% repeated(not_dgt(), lo = 0, hi = 18) %R% capture(repeated(DGT,0,2)) %R% one_or_more(printable())


i <- 0

for (df_name in df_names)  {
    i <- i + 1

column_names <- colnames(df_list[[df_name]])
logV <- str_detect(column_names, pattern = pattern3.3)
activity_no <- str_extract(df_name, pattern = "_" %R% repeated(DGT, 5, 6) %R% "_df" ) %>%
  str_remove_all("_") %>% str_remove("df")

raw_question_numbers_int <- str_extract(column_names[logV], pattern = pattern3.3)
raw_question_numbers <- str_extract(raw_question_numbers_int, pattern = START %R% "x" %R% DGT %R% optional(DGT))
raw_question_numbers %<>%  str_remove("x")

# extract 3 letter code for question type
pattern4 <- START %R% "x" %R% repeated(DGT,1,2) %R% "_" %R% repeated("[a-z]", lo = 3, hi = 3) %R% "_" 

question_type_int <- str_extract(column_names[logV], pattern = pattern4) 
# question_type <- str_remove(question_type_int, "_metadata_") %>% str_extract(repeated("[a-z]", lo = 3, hi = 3))

question_type <- str_extract(question_type_int, repeated("[a-z]", lo = 3, hi = 3))

maqV <- str_detect(column_names[logV], pattern = "_maq_")

if (sum(maqV)>0) {
  maq_option_no <- str_extract(column_names[logV], pattern =  "_maq_" %R% DGT %R% optional(DGT)) %>% str_remove("_maq") %>% str_replace_na(replacement = "NA") %>% str_replace("NA", "") 
question_numbers <- str_c("a", activity_no, "_", "q", raw_question_numbers, "_", question_type, maq_option_no, sep = "")  
  }

if (sum(maqV)==0) {
question_numbers <- str_c("a", activity_no, "_", "q", raw_question_numbers, "_", question_type, sep = "")  
  }

column_names[logV] <- question_numbers
colnames(df_list[[df_name]]) <- column_names   
  }   

```


```{r Create: extract data frames from list}
list2env(df_list, .GlobalEnv)

```

```{r Create: functions for joining data frames in df_list into *one* data frame}
# This function will assume that all of the data frames in df_list have the same research participant IDs, or at least that they are meant to all have the same IDs (if not it's assumed to be a missing data problem)
# Do I need different functions for one-off questionnaires vs EMAs? 

# first approximation
combined_df <- bind_rows(S3735_20908_df, S3735_20909_df, S3735_20910_df, .id = "id")
# need to add survey or activity no.s to the start of column names for this to work properly, else it will confuse same-named cols from different data frames 

```



************** STOP HERE ************

```{r end knit}
knitr::knit_exit()   

```


```{r tidy up 1}
# rm()

```


## Functions for preprocessing multiple answer questions    
```{r Create: functions for preprocessing multiple answer questions}
# # put NA in 1340_Q19_MAQ
# test_pathways_baselines_df <- test_pathways_baselines_df %>%
#     mutate_at(vars(`1340_Q19_MAQ`), ~ na_if(., ""))             # NB mutate_at() may be depreceated by nnow; replace
# 
# # create multiple cols for 1340_Q19_MAQ. First use str_split to create a matrix with one col for each answer, then make into df.
# diagnosed_conditions_mx <- str_split(string = test_pathways_baselines_df$`1340_Q19_MAQ`, pattern = " & ", simplify = TRUE)
# diagnosed_conditions_df <- as.data.frame(diagnosed_conditions_mx)
# 
# # Do I need a join to get the data in the right place? It seems not. 
# test_pathways_baselines_df <- bind_cols(test_pathways_baselines_df, diagnosed_conditions_df)
# 
# # rename columns. May need more code if someone has more than 6 answers. But I don't; the most answers anyone had was 6.  
# test_pathways_baselines_df <- rename(test_pathways_baselines_df, `1340_Q19_MAQ_1` = V1, `1340_Q19_MAQ_2` = V2, `1340_Q19_MAQ_3` = V3, `1340_Q19_MAQ_4` = V4, `1340_Q19_MAQ_5` = V5, `1340_Q19_MAQ_6` = V6)
# 
# # use str_replace to get numbers only, dump characters
# test_pathways_baselines_df <- test_pathways_baselines_df %>% 
#     mutate_at(vars(contains("1340_Q19_MAQ_")), number_extract_single)
# 
# # create col with concatenation of all Q19_MAQ cols
# test_pathways_baselines_df <- test_pathways_baselines_df %>% unite(`1340_Q19_MAQ_concat`, `1340_Q19_MAQ_1`:`1340_Q19_MAQ_6`, sep = ",", remove = FALSE)
# 
# # create binary cols for each concat answer
# pattern1 <- or1(c(",1,", ",1" %R% END, START %R% "1,"))
# pattern2 <- or1(c(",2,", ",2" %R% END, START %R% "2,"))
# pattern3 <- or1(c(",3,", ",3" %R% END, START %R% "3,"))
# pattern4 <- or1(c(",4,", ",4" %R% END, START %R% "4,"))
# pattern5 <- or1(c(",5,", ",5" %R% END, START %R% "5,"))
# pattern6 <- or1(c(",6,", ",6" %R% END, START %R% "6,"))
# pattern7 <- or1(c(",7,", ",7" %R% END, START %R% "7,"))
# pattern8 <- or1(c(",8,", ",8" %R% END, START %R% "8,"))
# pattern9 <- or1(c(",9,", ",9" %R% END, START %R% "9,"))
# pattern10 <- or1(c(",10,", ",10" %R% END, START %R% "10,"))
# 
# 
# test_pathways_baselines_df <- test_pathways_baselines_df %>% 
#     mutate(`1340_Q19_MAQ_option1` = ifelse(str_detect(string = `1340_Q19_MAQ_concat`, pattern = pattern1), TRUE, FALSE)) %>%
#     mutate(`1340_Q19_MAQ_option2` = ifelse(str_detect(string = `1340_Q19_MAQ_concat`, pattern = pattern2), TRUE, FALSE)) %>%
#     mutate(`1340_Q19_MAQ_option3` = ifelse(str_detect(string = `1340_Q19_MAQ_concat`, pattern = pattern3), TRUE, FALSE)) %>% 
#      mutate(`1340_Q19_MAQ_option4` = ifelse(str_detect(string = `1340_Q19_MAQ_concat`, pattern = pattern4), TRUE, FALSE)) %>% 
#      mutate(`1340_Q19_MAQ_option5` = ifelse(str_detect(string = `1340_Q19_MAQ_concat`, pattern = pattern5), TRUE, FALSE)) %>% 
#      mutate(`1340_Q19_MAQ_option6` = ifelse(str_detect(string = `1340_Q19_MAQ_concat`, pattern = pattern6), TRUE, FALSE)) %>% 
#     mutate(`1340_Q19_MAQ_option7` = ifelse(str_detect(string = `1340_Q19_MAQ_concat`, pattern = pattern7), TRUE, FALSE)) %>% 
#     mutate(`1340_Q19_MAQ_option8` = ifelse(str_detect(string = `1340_Q19_MAQ_concat`, pattern = pattern8), TRUE, FALSE)) %>% 
#     mutate(`1340_Q19_MAQ_option9` = ifelse(str_detect(string = `1340_Q19_MAQ_concat`, pattern = pattern9), TRUE, FALSE)) %>% 
#     mutate(`1340_Q19_MAQ_option10` = ifelse(str_detect(string = `1340_Q19_MAQ_concat`, pattern = pattern10), TRUE, FALSE))
# 
# test_pathways_baselines_df <- test_pathways_baselines_df %>% 
#     mutate_at(vars(`1340_Q19_MAQ_1`:`1340_Q19_MAQ_6`), ~ factor(., levels = c(1:10), labels = c("Heart disease", "Other heart condition", "Blood clot thrombosis", "Asthma", "Hay fever", "Depression", "Anxiety", "Thyroid problems", "None of these", "Other"), exclude = NA))

```

```{r Create: write CSV files if required}
# # Un-comment and add file path if a CSV file is required. NB Keep this function call at the end of the script.  
# # write.csv(pathways_df, file = "C:/your/file/path/something/like/output_files/your_filename.csv")   

```


```{r Deprecated}
# # testing
# x1 <- (df_list[[1]][[1,3]])
# number_extract_single2((df_list[[1]][[1,3]]))

# # more testing
# str_detect(x1, pattern = "{\"answer_id\":" %R% capture(DGT))  # TRUE 
# str_detect(x1, pattern = "\"answer_id\":" %R% capture(DGT) %R% one_or_more(printable()))  # TRUE

# # testing
# x1 <- "x1_saq_question_1_of_survey_1197"
# str_detect(x1, pattern2)
# str_extract(x1, pattern2)

# x2 <- "x1_saq_metadata_question_1_of_survey_1197"  
# str_detect(x2, pattern2)  # FALSE - good 

# target column name: S3735_s20908_q1 OR s20908_q1
# x2 <- "x1_saq_metadata_question_1_of_survey_1197"  
# pattern3 <- "_" %R% repeated("[a-z]", lo = 3, hi = 3) %R% "_metadata_question_" %R% capture(DGT) %R% 
#   repeated(capture(optional(DGT)),0,2) %R% "_of_survey_" %R% capture(DGT) %R%
#   repeated(capture(optional(DGT)),0,5)

# more test
# x6 <- "a,b\""
# pattern2 <- "_" %R% repeated("[a-z]", lo = 3, hi = 3) %R% "_question_" %R% "[0-9]"
# pattern_test <- repeated(not_dgt(), lo = 3, hi = 5)
# 
# str_detect(x6, pattern_test)

# # functions from pw_new2.10
# number_extract_single <- function(x) {
#   as.numeric(str_replace(x, 
#                          pattern = "\\(ID " %R% 
#                            capture(DGT) %R% 
#                            capture(optional(DGT)) %R% 
#                            "\\) " %R% 
#                            one_or_more(char_class("a-z","A-Z","0-9"," ")), 
#                          replacement = REF1))
#   }
# 
# number_extract_multiple <- function(x) {
#   as.numeric(str_replace(x, 
#                          pattern = one_or_more("\\(ID " %R% capture(DGT) %R% 
#                                                  capture(optional(DGT)) %R% "\\) " %R%
#                                                  one_or_more(char_class("a-z","A-Z","0-9", " "))),
#                          replacement = REF1 %R% REF2 %R% REF3 %R% REF4))
#   }


# # test
# x4 <- "{\"answer_id\":null,\"answer_content\":\"7\",\"answer_location\":{\"latitude\":null,\"longitude\":null,\"accuracy\":null,\"speed\":null},\"answer_response_time\":\"2024-02-19T03:35:15.692000+00:00\",\"answer_question_content\":\"In general how much of the time do you feel you are making progress towards accomplishing your goals?\\n(If your answer is zero you still have to move the slider back and forth so it knows you are not skipping the question.)\\n0 = Never\\n10 = Always\",\"answer_media_interactions\":[],\"unanswered_status_id\":null}"
# 
# str_detect(x4, pattern1.3)  #   
# 
# x5 <- "{\"answer_id\":2,\"answer_content\":\"A little of the time\",\"answer_location\":{\"latitude\":null,\"longitude\":null,\"accuracy\":null,\"speed\":null},\"answer_response_time\":\"2024-02-19T03:03:37.484000+00:00\",\"answer_question_content\":\"In the last four weeks about how often ...\\n\\n1. Did you feel tired out for no good reason?\",\"answer_media_interactions\":[],\"unanswered_status_id\":null}"
# 
# str_detect(x5, pattern1.3)  #  


# # create function to extract numerical data from 'metadata' column 
# pattern1 <- "\\{\"answer_id\":" %R% capture(DGT) %R% capture(optional(DGT)) %R% one_or_more(printable())
# 
# pattern1.1 <-  "\\{\"answer_id\":null,\"answer_content\":\"" %R% capture(DGT) %R% capture(optional(DGT)) %R% one_or_more(printable())
# 
# # rewrite pattern 1 for VAS and other question types 
# pattern1.2 <- group(or1(c(pattern1.1, pattern1), capture = TRUE))

# # # R chunk # # Clean single answer column data ----
# for (df_name in df_names)  { 
#   df_temp <- df_list[[df_name]] %>% mutate(across(where(contains("SAQ"))), number_extract_single)
#   df_list[[df_name]] <- df_temp
#   }
# 
# # Output from this chunk is df_list, a list of data frames with regularised variable names 
# ***********



```

```{r Create: functions for output cleaning}
# # Function to create column with count of NAs     # redundant- can use a fun from naniar:: or tidyr::, so replace 
# countRowNAs <- function(x) { sum(is.na(x)) }
# 
# count_NA <- function(data) {
#   apply(data, 1, countRowNAs)
# }     

```

```{r Test:    try to rewrite col name regex to include MAQ questions, eval=FALSE}
# # current regex
# pattern3.1 <- "_" %R% repeated("[a-z]", lo = 3, hi = 3) %R% "_metadata_question_" %R% capture(DGT) %R%
#   repeated(capture(optional(DGT)),0,2) %R% "_of_survey_" %R% (DGT) %R%
#   repeated(optional(DGT),0,5)
# 
# # sample non-MAQ and MAQ col names
# nonmaq <- "x2_saq_metadata_question_2_of_survey_1197"
#    maq <- "x10_maq_2_any_meat"
# 
# str_detect(nonmaq, pattern3.1)    # TRUE
# str_detect(maq, pattern3.1)       # FALSE
# 
# # new regex for MAQ only
# pattern3.2 <- START %R% "x" %R% capture(repeated(DGT,1,2)) %R% "_" %R% repeated("[a-z]", lo = 3, hi = 3) %R% "_" %R% capture(repeated(DGT,1,2)) %R% one_or_more(printable())
# 
# str_detect(nonmaq, pattern3.2)    # FALSE
# str_detect(maq, pattern3.2)       # TRUE
# 
# str_replace(nonmaq, pattern = pattern3.2, replacement = REF1 %R% "_" %R% REF2)
#                                                         # "x2_saq_metadata_question_2_of_survey_1197"
# str_replace(maq, pattern = pattern3.2, replacement = REF1 %R% "_" %R% REF2)      # "10_2"
# 
# # attempt regex for MAQ _and_ SAQ, VAS, etc
# pattern3.3 <- START %R% "x" %R% capture(repeated(DGT,0,2)) %R% "_" %R% repeated("[a-z]", lo = 3, hi = 3) %R% "_" %R% repeated(not_dgt(), lo = 0, hi = 18) %R% capture(repeated(DGT,0,2)) %R% one_or_more(printable())
# 
# str_detect(nonmaq, pattern3.3)    # TRUE
# str_detect(maq, pattern3.3)       # TRUE
# 
# str_replace(nonmaq, pattern3.3, replacement = REF1 %R% "_" %R% REF2)        # s/be "2_2"   # "2_2"
# str_replace(maq, pattern = pattern3.3, replacement = REF1 %R% "_" %R% REF2) # s/be "10_2"  # "10_2"

```

```{r checks of length for rename answer columns chunk, eval=FALSE}
# length(column_names)
# length(logV)
# length(raw_question_numbers_int)
# length(raw_question_numbers)
# length(question_type_int)
# length(question_type)
# length(maqV)
# length(maq_option_no)
# length(question_numbers)

```

```{r checks for rename answer columns chunk, eval=FALSE}
# # inspect intermediate objects
# column_names # not useful as overwritten  
# logV
# raw_question_numbers_int
# raw_question_numbers
# question_type_int
# question_type
# maqV
# maq_option_no
# question_numbers   
```
